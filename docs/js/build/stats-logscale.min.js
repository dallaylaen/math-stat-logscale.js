(()=>{var t={10:(t,e,s)=>{(()=>{const{Binning:e}=s(365),{Univariate:i}=s(513),r={Binning:e,Univariate:i};"undefined"!=typeof window&&(window.logstat=r),t.exports=r})()},365:t=>{"use strict";function e(t,s,i=10){if(t===s)return t;if(t*s<=0)return 0;if(s<0)return-e(-s,-t,i);if(t>s)return e(s,t,i);let r=-Math.floor(Math.log(s-t)/Math.log(i));for(;Math.ceil(t*i**r)<=Math.floor(s*i**r);)r--;return r++,r>=0?Math.ceil(t*i**r)/i**r:Math.ceil(t/i**-r)*i**-r}t.exports={Binning:class{constructor(t={}){let e=!t.flat&&t.base||1.001,s=t.precision??1e-9;if(!(s>0))throw new Error("precision must be a positive number");if(!(e>1&&e<1.5))throw new Error("base must be a number between 1 and 1.5");if(e+=1e-9,e=2**(1/Math.ceil(Math.log(2)/Math.log(e))),1===e)throw new Error("base too close to 1");s=Number.parseFloat(""+s);const i=Math.ceil(1/(e-1)),r=t.flat?1/0:s*i;t.flat?this._flat=!0:this._base=e,this._thresh=r,this._precision=s}toJSON(){return this._flat?{precision:this._precision,flat:!0}:{precision:this._precision,base:this._base}}getBase(){return this._base}getPrecision(){return this._precision}round(t){if("number"!=typeof t&&(t=Number.parseFloat(t)),Number.isNaN(t))throw new Error("Attempt to round a non-numeric value: "+t);return t<0?-this.round(-t):t<this._thresh?Math.round(t/this._precision)*this._precision:this._thresh*this._base**Math.round(Math.log(t/this._thresh)/Math.log(this._base))}upper(t){return t<0?-this.lower(-t):(t=this.round(t))<this._thresh?t+this._precision/2:t*Math.sqrt(this._base)}lower(t){return t<0?-this.upper(-t):(t=this.round(t))<=this._thresh?t-this._precision/2:t/Math.sqrt(this._base)}shorten(t,s){return void 0===t?t:void 0===s?e(this.lower(t),this.upper(t)):e(t,s)}},shorten:e}},513:(t,e,s)=>{"use strict";const{Binning:i}=s(365);class r extends i{constructor(t={}){super(t),this.storage=new Map,this._count=0,this._cache={},this.neat=new n(this),t.bins&&this.addWeighted(t.bins)}add(...t){return this._cache={},t.forEach((t=>{const e=this.round(t),s=this.storage.get(e)??0;this.storage.set(e,s+1),this._count++})),this}addWeighted(t){return this._cache={},t.forEach((t=>{const e=t[0],s=Number.parseFloat(t[1]);if(Number.isNaN(s))throw new Error("Attempt to provide a non-numeric weight");const i=this.round(e),r=(this.storage.get(i)??0)+s;r<=0?(this.storage.delete(i),this._count+=s-r):(this.storage.set(i,r),this._count+=s)})),this}toJSON(){return{version:"stats-logscale/univariate@1.0",...super.toJSON(),bins:this.getBins()}}clone(t={}){let e=this.getBins(t);return t.transform&&(e=e.map((e=>[t.transform(e[0]),e[1]]))),new r({...super.toJSON(),bins:e})}getBins(t){if(this._cache.data||(this._cache.data=[...this.storage].sort(((t,e)=>t[0]-e[0]))),!t)return this._cache.data;const e=Math.max(t.min??-1/0,this.percentile(t.ltrim??0)),s=Math.min(t.max??1/0,this.percentile(100-(t.rtrim??0)));if(!t.winsorize)return this._cache.data.filter((t=>t[0]>=e&&t[0]<=s));const i=[this.round(e),0],r=[this.round(s),0],n=[i];for(const[t,e]of this._cache.data)t<=i[0]?i[1]+=e:t>=r[0]?r[1]+=e:n.push([t,e]);return r[1]>0&&n.push(r),n}count(){return this._count}min(){const t=this.getBins();return this.lower(t[0][0])}max(){const t=this.getBins();return this.upper(t[t.length-1][0])}sumOf(t){let e=0;return[...this.storage].forEach((s=>{e+=s[1]*t(s[0])})),e}E(t){return this._count?this.sumOf(t)/this._count:void 0}mean(){return this._count?this.sumOf((t=>t))/this._count:void 0}stdev(){if(this._count<2)return;const t=this.mean();return Math.sqrt(this.sumOf((e=>(e-t)*(e-t)))/(this._count-1))}skewness(){const t=this.count();if(!(t<3))return t*t/((t-1)*(t-2))*this.momentStd(3)}kurtosis(){const t=this.count();if(t<4)return;const e=t*t*(t+1)/((t-1)*(t-2)*(t-3)),s=(t-1)*(t-1)/((t-2)*(t-3));return this.momentStd(4)*e-3*s}moment(t,e){if(!Number.isInteger(t))throw new Error("Cannot calculate non-integer moment (did you mean momentAbs?)");return void 0===e&&(e=this.mean()),this.E((s=>(s-e)**t))}momentAbs(t=1,e){return void 0===e&&(e=this.mean()),this.E((s=>Math.abs(s-e)**t))}momentStd(t){return this.moment(t)/this.stdev()**t}quantile(t){const e=t*this._count,s=this._cumulative();let i=0,r=s.length;for(;i+1<r;){const t=Math.floor((r+i)/2);s[t][1]>=e?r=t:i=t}const n=this.lower(s[i][0]);return n+(this.upper(s[i][0])-n)*(e-s[i][1])/(s[i][2]-s[i][1])}percentile(t){return this.quantile(t/100)}median(){return this.quantile(.5)}cdf(t){return this._rawCdf(t)/this._count}_rawCdf(t){const e=this._cumulative(),s=this.round(t);let i=0,r=e.length;for(;i<r;){const t=Math.floor((r+i)/2);e[t][0]<s?i=t+1:r=t}if(i>=e.length)return this._count;let n=i>0?e[i-1][2]:0;if(s===e[i][0]){const s=this.upper(t)-this.lower(t),r=e[i][2]-e[i][1];n+=s>0?r*(t-this.lower(t))/s:r/2}return n}histogram(t={}){if(!this._count)return[];const e=this.min(),s=this.max(),i=t.count||10,r=[];let n=e;const o=(s-e)/i;for(let t=0;t<i;t++)r.push([this._rawCdf(n+o),n,n+=o]);for(let t=r.length;t-- >1;)r[t][0]-=r[t-1][0];if(r[0][0]-=this._rawCdf(e),t.scale){let e=0;for(let t=0;t<r.length;t++)e<r[t][0]&&(e=r[t][0]);for(let s=0;s<r.length;s++)r[s][0]=r[s][0]*t.scale/e}return r}_cumulative(){if(!this._cache.cumulative){const t=this.getBins(),e=[];let s=0;for(let i=0;i<t.length;i++)e.push([t[i][0],s,s+=t[i][1]]);this._cache.cumulative=e}return this._cache.cumulative}}["cdf+","kurtosis","max","mean","min","moment+","momentAbs+","momentStd+","quantile+","skewness","stdev"].forEach((t=>{const e=!!t.match(/\+/);e&&(t=t.replace("+",""));const s=r.prototype[t];if("function"!=typeof s)throw new Error('method "'+t+'" is cached but never defined');r.prototype[t]=e?function(...e){if(0===this._count)return;void 0===this._cache[t]&&(this._cache[t]={});const i=e.join(":");return void 0===this._cache[t][i]&&(this._cache[t][i]=s.apply(this,e)),this._cache[t][i]}:function(){if(0!==this._count)return void 0===this._cache[t]&&(this._cache[t]=s.apply(this)),this._cache[t]}}));class n{constructor(t){this._main=t}min(){if(!this._main._count)return;const t=this._main.getBins();return this._main.shorten(t[0][0])}max(){if(!this._main._count)return;const t=this._main.getBins();return this._main.shorten(t[t.length-1][0])}}["E","kurtosis","mean","median","moment","momentAbs","momentStd","percentile","quantile","skewness","stdev","sumOf"].forEach((t=>{n.prototype[t]=function(e){return this._main.shorten(this._main[t](e))}})),["cdf","count"].forEach((t=>{n.prototype[t]=function(e){return this._main[t](e)}})),t.exports={Univariate:r}}},e={};!function s(i){var r=e[i];if(void 0!==r)return r.exports;var n=e[i]={exports:{}};return t[i](n,n.exports,s),n.exports}(10)})();