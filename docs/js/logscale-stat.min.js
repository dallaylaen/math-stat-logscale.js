(()=>{"use strict";var t={10:(t,e,i)=>{(()=>{const{Binning:e}=i(365),{Univariate:s}=i(513),r={Binning:e,Univariate:s};"undefined"!=typeof window?window.logstat=r:t.exports=r})()},365:t=>{function e(t,i,s=10){if(t===i)return t;if(t*i<=0)return 0;if(i<0)return-e(-i,-t,s);if(t>i)return e(i,t,s);let r=-Math.floor(Math.log(i-t)/Math.log(s));for(;Math.ceil(t*s**r)<=Math.floor(i*s**r);)r--;return r++,r>=0?Math.ceil(t*s**r)/s**r:Math.ceil(t/s**-r)*s**-r}t.exports={Binning:class{constructor(t={}){let e=t.base||1.001,i=t.precision||1e-9;if(!(e>1&&e<1.5))throw new Error("base must be a number between 1 and 1.5");if(e+=1e-9,e=2**(1/Math.ceil(Math.log(2)/Math.log(e))),1===e)throw new Error("base too close to 1");i=Number.parseFloat(""+i);const s=i*Math.ceil(1/(e-1));this._thresh=s,this._precision=i,this._base=e}getBase(){return this._base}getPrecision(){return this._precision}round(t){if("number"!=typeof t&&(t=Number.parseFloat(t)),Number.isNaN(t))throw new Error("Attempt to round a non-numeric value: "+t);return t<0?-this.round(-t):t<this._thresh?Math.round(t/this._precision)*this._precision:this._thresh*this._base**Math.round(Math.log(t/this._thresh)/Math.log(this._base))}upper(t){return t<0?-this.lower(-t):(t=this.round(t))<this._thresh?t+this._precision/2:t*Math.sqrt(this._base)}lower(t){return t<0?-this.upper(-t):(t=this.round(t))<=this._thresh?t-this._precision/2:t/Math.sqrt(this._base)}shorten(t,i){return void 0===t?t:void 0===i?e(this.lower(t),this.upper(t)):e(t,i)}},shorten:e}},513:(t,e,i)=>{const{Binning:s}=i(365);class r extends s{constructor(t={}){super(t),this.storage={},this._count=0,this._cache={},this.neat=new n(this),t.bins&&this.addWeighted(t.bins)}add(...t){return this._cache={},t.forEach((t=>{const e=this.round(t);this.storage[e]||(this.storage[e]=[0,e]),this.storage[e][0]++,this._count++})),this}addWeighted(t){return this._cache={},t.forEach((t=>{const e=t[0],i=Number.parseFloat(t[1]);if(Number.isNaN(i))throw new Error("Attempt to provide a non-numeric weight");const s=this.round(e);this.storage[s]||(this.storage[s]=[0,s]),this.storage[s][0]+=i,this._count+=i})),this}toJSON(){return{precision:this.getPrecision(),base:this.getBase(),bins:this.getBins()}}clone(t={}){return new r({precision:t.precision??this.getPrecision(),base:t.base??this.getBase(),bins:this.getBins(t)})}getBins(t){if(this._cache.data||(this._cache.data=Object.values(this.storage).map((t=>[t[1],t[0]])).sort(((t,e)=>t[0]-e[0]))),!t)return this._cache.data;const e=Math.max(t.min??-1/0,this.percentile(t.ltrim??0)),i=Math.min(t.max??1/0,this.percentile(100-(t.rtrim??0)));return this._cache.data.filter((t=>t[0]>=e&&t[0]<=i))}count(){return this._count}min(){const t=this.getBins();return this.lower(t[0][0])}max(){const t=this.getBins();return this.upper(t[t.length-1][0])}sumOf(t){let e=0;return Object.values(this.storage).forEach((i=>{e+=i[0]*t(i[1])})),e}E(t){return this._count?this.sumOf(t)/this._count:void 0}mean(){return this._count?this.sumOf((t=>t))/this._count:void 0}stdev(){if(this._count<2)return;const t=this.mean();return Math.sqrt(this.sumOf((e=>(e-t)*(e-t)))/(this._count-1))}moment(t,e){if(!Number.isInteger(t))throw new Error("Cannot calculate non-integer moment (did you mean momentAbs?)");return void 0===e&&(e=this.mean()),this.E((i=>(i-e)**t))}momentAbs(t=1,e){return void 0===e&&(e=this.mean()),this.E((i=>Math.abs(i-e)**t))}quantile(t){const e=t*this._count,i=this._cumulative();let s=0,r=i.length;for(;s+1<r;){const t=Math.floor((r+s)/2);i[t][1]>=e?r=t:s=t}const n=this.lower(i[s][0]);return n+(this.upper(i[s][0])-n)*(e-i[s][1])/(i[s][2]-i[s][1])}percentile(t){return this.quantile(t/100)}median(){return this.quantile(.5)}cdf(t){return this.rawCdf(t)/this._count}rawCdf(t){if(!this._count||t<=this.min())return 0;if(t>=this.max())return this._count;const e=this._cumulative(),i=this.round(t);let s=0,r=e.length;for(;s+1<r;){const t=Math.floor((r+s)/2);e[t][0]<=i?s=t:r=t}return i>e[s][0]?e[s][2]:e[s][1]+(e[s][2]-e[s][1])*(t-this.lower(t))/(this.upper(t)-this.lower(t))}histogram(t={}){if(!this._count)return[];const e=this.min(),i=this.max(),s=t.count||10,r=[];let n=e;const h=(i-e)/s;for(let t=0;t<s;t++)r.push([this.rawCdf(n+h),n,n+=h]);for(let t=r.length;t-- >1;)r[t][0]-=r[t-1][0];if(r[0][0]-=this.rawCdf(e),t.scale){let e=0;for(let t=0;t<r.length;t++)e<r[t][0]&&(e=r[t][0]);for(let i=0;i<r.length;i++)r[i][0]=r[i][0]*t.scale/e}return r}_cumulative(){if(!this._cache.cumulative){const t=this.getBins(),e=[];let i=0;for(let s=0;s<t.length;s++)e.push([t[s][0],i,i+=t[s][1]]);this._cache.cumulative=e}return this._cache.cumulative}}["cdf+","max","mean","min","moment+","momentAbs+","quantile+","stdev"].forEach((t=>{const e=!!t.match(/\+/);e&&(t=t.replace("+",""));const i=r.prototype[t];r.prototype[t]=e?function(...e){if(0===this._count)return;void 0===this._cache[t]&&(this._cache[t]={});const s=e.join(":");return void 0===this._cache[t][s]&&(this._cache[t][s]=i.apply(this,e)),this._cache[t][s]}:function(){if(0!==this._count)return void 0===this._cache[t]&&(this._cache[t]=i.apply(this)),this._cache[t]}}));class n{constructor(t){this._main=t}min(){if(!this._main._count)return;const t=this._main.getBins();return this._main.shorten(t[0][0])}max(){if(!this._main._count)return;const t=this._main.getBins();return this._main.shorten(t[t.length-1][0])}}["E","mean","median","moment","momentAbs","percentile","quantile","stdev"].forEach((t=>{n.prototype[t]=function(e){return this._main.shorten(this._main[t](e))}})),["cdf","count"].forEach((t=>{n.prototype[t]=function(e){return this._main[t](e)}})),t.exports={Univariate:r}}},e={};!function i(s){var r=e[s];if(void 0!==r)return r.exports;var n=e[s]={exports:{}};return t[s](n,n.exports,i),n.exports}(10)})();