(()=>{"use strict";var t={10:(t,s,e)=>{(()=>{const{Binning:s}=e(365),{Univariate:r}=e(513),i={Binning:s,Univariate:r};"undefined"!=typeof window?window.logstat=i:t.exports=i})()},365:t=>{t.exports={Binning:class{constructor(t={}){let s=t.base||1.001,e=t.precision||1e-9;if(!(s>1&&s<1.5))throw new Error("base must be a number between 1 and 1.5");if(s=2**(1/Math.ceil(Math.log(2)/Math.log(s))),s=Number.parseFloat(""+s),1===s)throw new Error("base too close to 1");let r=e/(s-1);const i=Math.ceil(r/e);e=r/i,r=e*i,this._thresh=r,this._precision=e,this._base=s}getBase(){return this._base}getPrecision(){return this._precision}round(t){if(Number.isNaN(t+0))throw new Error("Attempt to round a non-numeric value: "+t);return t<0?-this.round(-t):t<this._thresh?Math.round(t/this._precision)*this._precision:this._thresh*this._base**Math.round(Math.log(t/this._thresh)/Math.log(this._base))}upper(t){return t<0?-this.lower(-t):(t=this.round(t))<this._thresh?t+this._precision/2:t*Math.sqrt(this._base)}lower(t){return t<0?-this.upper(-t):(t=this.round(t))<=this._thresh?t-this._precision/2:t/Math.sqrt(this._base)}}}},513:(t,s,e)=>{const{Binning:r}=e(365);t.exports={Univariate:class extends r{constructor(t={}){super(t),this.storage={},this._count=0,this._cache={}}add(...t){return this._cache={},t.forEach((t=>{const s=this.round(t);this.storage[s]||(this.storage[s]=[0,s]),this.storage[s][0]++})),this._count+=t.length,this}addWeighted(t){return this._cache={},t.forEach((t=>{const s=this.round(t[0]);this.storage[s]||(this.storage[s]=[0,s]),this.storage[s][0]+=t[1],this._count+=t[1]})),this}data(){return this._cache.data||(this._cache.data=Object.values(this.storage).map((t=>[t[1],t[0]])).sort(((t,s)=>t[0]-s[0]))),this._cache.data}count(){return this._count}min(){if(!this._count)return;const t=this.data();return this.lower(t[0][0])}max(){if(!this._count)return;const t=this.data();return this.upper(t[t.length-1][0])}integrate(t){let s=0;return Object.values(this.storage).forEach((e=>{s+=e[0]*t(e[1])})),s}expected(t){return this._count?this.integrate(t)/this._count:void 0}mean(){return this._count?this.integrate((t=>t))/this._count:void 0}stdev(){if(this._count<2)return 1/0;const t=this.mean();return Math.sqrt(this.integrate((s=>(s-t)*(s-t)))/(this._count-1))}quantile(t){const s=t*this._count,e=this._cumulative();let r=0,i=e.length;for(;r+1<i;){const t=Math.floor((i+r)/2);e[t][1]>=s?i=t:r=t}const h=this.lower(e[r][0]);return h+(this.upper(e[r][0])-h)*(s-e[r][1])/(e[r][2]-e[r][1])}cdf(t){return this.rawCdf(t)/this._count}rawCdf(t){if(!this._count||t<=this.min())return 0;if(t>=this.max())return this._count;const s=this._cumulative(),e=this.round(t);let r=0,i=s.length;for(;r+1<i;){const t=Math.floor((i+r)/2);s[t][0]<=e?r=t:i=t}return e>s[r][0]?s[r][2]:s[r][1]+(s[r][2]-s[r][1])*(t-this.lower(t))/(this.upper(t)-this.lower(t))}histogram(t={}){if(!this._count)return[];const s=this.min(),e=this.max(),r=t.count||10,i=[];let h=s;const n=(e-s)/r;for(let t=0;t<r;t++)i.push([this.rawCdf(h+n),h,h+=n]);for(let t=i.length;t-- >1;)i[t][0]-=i[t-1][0];if(i[0][0]-=this.rawCdf(s),t.scale){let s=0;for(let t=0;t<i.length;t++)s<i[t][0]&&(s=i[t][0]);for(let e=0;e<i.length;e++)i[e][0]=i[e][0]*t.scale/s}return i}_cumulative(){if(!this._cache.cumulative){const t=this.data(),s=[];let e=0;for(let r=0;r<t.length;r++)s.push([t[r][0],e,e+=t[r][1]]);this._cache.cumulative=s}return this._cache.cumulative}}}}},s={};!function e(r){var i=s[r];if(void 0!==i)return i.exports;var h=s[r]={exports:{}};return t[r](h,h.exports,e),h.exports}(10)})();