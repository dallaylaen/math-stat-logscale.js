<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Univariate statistical analysis</title>
    <script src="js/logscale-stat.js"></script>
</head>
<body>
<canvas id="draw" style="border: solid red 1px"></canvas>

<table>
<tbody id="summary">
</tbody>
</table>
<div>
<select id="query" onchange="toggleQueryParam()"></select>
<input id="query-param" style="display: none">
<button onclick="addQuery()">add...</button>
</div>

<div id="add-numbers">
<p style="color:grey">Enter code here. Use <tt>stat.add( number, ... )</tt>
to add numbers to the dataset
and <tt>data</tt> to refer to uploaded file content (if any).</p>
<textarea id="code" style="width: 80%; height: 10em">
for( let i = 0; i<10000; i++) {
    stat.add(-Math.log(Math.random()));
};
</textarea><br>
<input type="file" id="file">
<button onclick="return run()">Run code</button>
<button onclick="return reset()">Reset stat</button>
</div>

<script>
    const summaryTable  = document.getElementById('summary');
    const userCode      = document.getElementById('code');
    const canvas        = document.getElementById('draw');
    const inFile        = document.getElementById('file');
    const selectQuery   = document.getElementById('query');
    const queryParam    = document.getElementById('query-param');

    let stat;
    const summary = [];

    const availSeed = [
        [ 'count' ],
        [ 'min' ],
        [ 'max' ],
        [ 'mean' ],
        [ 'stdev', 'standard deviation' ],
        [ 'quantile', 'quantile(0..1)', 0, 1 ],
        [ 'cdf', 'P(value&lt;x)', -Infinity, Infinity ],
        [ 'E', 'E(function)', 'function' ],
    ];
    const avail = {};

    availSeed.forEach( spec => {
        avail[spec[0]] = spec;
        const name = spec[0];
        const label = spec[1] || name;
        selectQuery.innerHTML += '<option value="'+name+'">'+label+'</option>';
    });

    function toggleQueryParam() {
        const name = selectQuery.value;
        if (avail[name][2] === undefined)
            queryParam.style = 'display: none';
        else
            queryParam.style = '';
        queryParam.value = '';
    }

    function addQuery() {
        const name = selectQuery.value;
        const spec = avail[name];
        let param;
        if (spec[2] !== undefined) {
            param = queryParam.value;
            if (spec[2] === 'function')
                param = eval(param);
            else {
                param = Number.parseFloat(param);
                if (!(param >= spec[2] && param <= spec[3]))
                    return; // out of range
            }
        }
        addSummary(name, param);
        show();
    }

    function run() {
        const code = userCode.value;

        // TODO isolate via web workers if available
        // TODO fancy error msg

        const promise = inFile.files[0] ? inFile.files[0].text() : Promise.resolve('');

        promise.then( resolve => {
            let data = '' + resolve;
            eval(code);
            show();
            draw();
        });
    }

    function reset() {
        stat = new logstat.Univariate();
        // TODO also specify precision
        show();
        draw();
    }

    function addSummary (name, param) {
        summary.push( [ name, param ] );
    }

    function delSummary(n) {
        summary.splice(n,1);
        show();
        return false;
    }

    function show() {
        summaryTable.innerHTML = '';
        for (let i = 0; i<summary.length; i++) {
            const [name, param] = summary[i];
            const tr = document.createElement('tr');

            let value;
            try {
                value = stat.neat[name](param)
            } catch (e) {
                value = e;
            }

            tr.innerHTML = '<td align="right">'+name
                +'</td><td>'
                +(param !== undefined ? '('+param+')' : '')
                +'</td><td>'
                +value
                +'</td><td>'
                +'<a href="#" onclick="return delSummary('+i+')">[x]</a>'
                +'</td>';

            summaryTable.appendChild(tr);
        }
    }

    const graphColoring = [
            [0,    'orange'],
            [0.05, 'yellow'],
            [0.25, 'blue' ],
            [0.5,  'yellow' ],
            [0.75, 'blue' ],
            [0.95, 'orange'],
            [1,    'red']
    ];

    const em = 8;

    function draw() {
        const height = Math.floor(Number.parseInt(screen.height) / 5);
        const width  = Math.floor(Number.parseInt(screen.width) * 0.8) - 10;

        canvas.height = height + em*2;
        canvas.width = width + em*6;

        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.stroke();
        ctx.fillStyle = 'lightgrey';
        ctx.fillRect(em, 0, canvas.width-em*6, canvas.height-em*2);
        ctx.stroke();

        if(!stat.count())
            return;

        const min = stat.min();
        const step = (stat.max() - min) / width;
        const num2pic = x => (x - min) / step + em;

        ctx.lineWidth = 1;

        const hist = stat.histogram({count:width, scale:height});
        const parts = graphColoring.map( x => [ stat.quantile(x[0]), x[1]] );
        let partNum = 0;

        for (let i = 0; i<width; i++) {
            if (hist[i][1] >= parts[partNum][0])
                ctx.strokeStyle = parts[partNum++][1];

            ctx.beginPath();
            ctx.moveTo( i + em, height );
            ctx.lineTo( i + em, height - Math.ceil(hist[i][0]) );
            ctx.stroke();
        }

        // mean +- stdev
        const meanStd = [-1,0,1].map( x => stat.mean() + x*stat.stdev() )
            .map( num2pic );
        ctx.beginPath();
        ctx.strokeStyle = 'orange';
        ctx.moveTo( meanStd[0], canvas.height-em );
        ctx.lineTo( meanStd[2], canvas.height-em );
        ctx.moveTo( meanStd[0], canvas.height-em*1.4 );
        ctx.lineTo( meanStd[0], canvas.height-em*0.6 );
        ctx.moveTo( meanStd[1], canvas.height-em*1.6 );
        ctx.lineTo( meanStd[1], canvas.height-em*0.4 );
        ctx.moveTo( meanStd[2], canvas.height-em*1.4 );
        ctx.lineTo( meanStd[2], canvas.height-em*0.6 );
        ctx.stroke();

        for (let i = 0; i<11; i++) {
            ctx.beginPath();
            ctx.fillStyle = '#222222';
            ctx.font = em + 'px Sans';
            const label = stat.shorten(stat.min() + (stat.max() - stat.min())*i/10);
            ctx.setLineDash([1,3]);
            ctx.moveTo( width*i/10 + em, canvas.height-em*1.5 );
            ctx.lineTo( width*i/10 + em, 0 );
            ctx.stroke();
            ctx.strokeStyle = 'black';
            ctx.setLineDash([1,0]);
            ctx.fillText( label, width*i/10 + em, canvas.height-1 );
        }

        for (let i = 0; i<graphColoring.length-1; i++) {
            ctx.beginPath();
            ctx.fillStyle = graphColoring[i][1];
            ctx.fillRect(em+width+2, i*em*2+2, em*1.5, em*1.5);
            ctx.stroke();

            const label = graphColoring[i+1][0] * 100 + '%';
            ctx.beginPath();
            ctx.fillStyle = '#222222';
            ctx.fillText( label,  em*3+width, i*em*2+em*1.5);
        }
    }

    // Initialize stuff
    addSummary( 'count' );
    addSummary( 'min' );
    addSummary( 'max' );
    addSummary( 'mean' );
    addSummary( 'stdev' );
    addSummary( 'quantile', 0.5 );
    reset();

</script>
</body>
</html>
